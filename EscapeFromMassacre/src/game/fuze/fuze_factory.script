local MainState = require "src.main_state"
local Utils = require "src.utils.utils"
local MSG = require "src.utils.messages"
local debugUtils = require "src.utils.debug-utils"
local log = debugUtils.createLog("[FUZE_FACTORY]").log

local random_position = Utils.random_position

local function create_fuze(color, pos)
	return factory.create("#factory-fuze", pos or random_position(), nil, {remote = false, color = color})
end

local function use_map_level_visibility(self, map_level)
	if self.fuzeOnMapLevel == nil then
		return
	end

	for key, val in pairs(self.fuzeOnMapLevel) do
		if val.fuze ~= nil and go.exists(val.fuze) then
			if val.map == map_level then
				msg.post(val.fuze, "enable")
			else
				msg.post(val.fuze, "disable")
			end
		end
	end
end

function init(self)
	log("init", self.color, self.map_level)
	self.isServer = MainState.isServer
	self.fuzeOnMapLevel = {}


	if self.isServer then
		MainState.INITIAL_FUZES_CREATE = {}
		table.insert(MainState.INITIAL_FUZES_CREATE, {color = MainState.FUZE.RED, pos = Utils.random_position()})
		table.insert(MainState.INITIAL_FUZES_CREATE, {color = MainState.FUZE.GREEN, pos = Utils.random_position()})
		table.insert(MainState.INITIAL_FUZES_CREATE, {color = MainState.FUZE.BLUE, pos = Utils.random_position()})
		table.insert(MainState.INITIAL_FUZES_CREATE, {color = MainState.FUZE.YELLOW, pos = Utils.random_position()})

		for _, v in ipairs(MainState.INITIAL_FUZES_CREATE) do
			log(v.color, v.pos)
			self.fuzeOnMapLevel[v.color] = {
				map = MainState.fuzeColorToMapLevel[v.color],
				fuze = create_fuze(v.color, v.pos)}
		end

		--use_map_level_visibility(self, MainState.playerOnMapLevel)
	end

	-- self.zombies = MainState.zombies
	-- for i = 1, 10 do
	-- 	local obj = MainState.createGameObject(spawn_zombie())
	-- 	self.zombies:put(obj.id, obj)
	-- end
end

function final(self)
	if self.fuzeOnMapLevel == nil then
		return
	end
	print("clear fuzes")
	for key, val in pairs(self.fuzeOnMapLevel) do
		print("clear fuzes:", val.fuze)
		if val.fuze ~= nil and go.exists(val.fuze) then
			go.delete(val.fuze)
		end
	end
end

function on_message(self, message_id, message, sender)
	--if message_id == MSG.LEVEL_CHANGE.map_level_change.hash then
	--	use_map_level_visibility(self, message.map_level)
	--elseif message_id == MSG.FUZE_FACTORY.create_fuzes.hash then
	--	self.fuzeOnMapLevel = {
	--		[MainState.FUZE.RED] = {
	--			map = MainState.MAP_LEVELS.HOUSE,
	--			fuze = create_fuze(message.color_red, message.color_red_pos)},
	--		[MainState.FUZE.GREEN] = {
	--			map = MainState.MAP_LEVELS.HOUSE,
	--			fuze = create_fuze(message.color_green, message.color_green_pos)},
	--		[MainState.FUZE.BLUE] = {
	--			map = MainState.MAP_LEVELS.BASEMENT,
	--			fuze = create_fuze(message.color_blue, message.color_blue_pos)},
	--		[MainState.FUZE.YELLOW] = {
	--			map = MainState.MAP_LEVELS.BASEMENT,
	--			fuze = create_fuze(message.color_yellow, message.color_yellow_pos)},
	--	}
	--	use_map_level_visibility(self, MainState.playerOnMapLevel)
	--elseif message_id == MSG.FUZE_FACTORY.pick_fuze.hash then
	--	go.delete(self.fuzeOnMapLevel[message.color].fuze)
	--	self.fuzeOnMapLevel[message.color].fuze = nil
	--elseif message_id == MSG.FUZE_FACTORY.throw_fuze.hash then
	--	local fuze = create_fuze(message.color, message.pos)
	--	self.fuzeOnMapLevel[message.color] = {map = message.map_level, fuze = fuze}
	--	-- local to = message.pos
	--	-- to.x = to.x + 30
	--	-- to.y = to.y + 30
	--	-- go.animate(fuze, "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, 0.25, 0, function() end)
	--end
end
