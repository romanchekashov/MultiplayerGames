local input = require "ludobits.m.input"
local MainState = require "src.main_state"
local debugUtils = require "src.utils.debug-utils"
local defoldUtils = require "src.utils.defold-utils"
local ACTION_IDS = require "src.utils.actions"
local device = require "src.utils.device"
local MSG = require "src.utils.messages"
local multiplayer_input = require "server.multiplayer_input"
local broadsock = require "server.server_broadsock"
local Utils = require "src.utils.utils"

local get_timestamp_in_ms = Utils.get_timestamp_in_ms
local isGamepadLeftStickActionId = ACTION_IDS.isGamepadLeftStickActionId
local isGamepadRightStickActionId = ACTION_IDS.isGamepadRightStickActionId
local IS_MOBILE = device.type == "mobile" or device.type == "tablet"
local log = debugUtils.createLog("[PLAYER]").log
local getRotation = defoldUtils.getRotation

local insidePauseBound = MainState.insidePauseBound
local insideVirtualGamepadLeftStickBound = defoldUtils.insideVirtualGamepadLeftStickBound
local insideVirtualGamepadButtonsBounds = defoldUtils.insideVirtualGamepadButtonsBounds

go.property("angular_velocity", 5)
go.property("linear_velocity", 200)
go.property("remote", true)
go.property("uid", 0)
go.property("map_level", 0)
go.property("player_type", 0)


local MSG_GROUPS = MainState.MSG_GROUPS

local STAIRS_TO_BASEMENT = hash("stairs_to_basement")
local STAIRS_TO_HOUSE = hash("stairs_to_house")
local FUSE = hash("fuse")
local FUSE_BOX = hash("fuse_box")
local KNIFE = hash("knife")

local STICK_MAX_DISTANCE = 30
local PLAYER_SPEED = 275
local PLAYER_SPEED_CLOSE_TO_WALL = 150
local STAIRS_CHANGE_COOLDOWN = 1
local HIT_COOLDOWN = 0.2
local ZOMBIE_HIT_COOLDOWN = 0.6
local FIRE_COOLDOWN = 0.2
local rad_minus90 = math.rad(-90)

local CROSSHAIR_OFFSET = vmath.vector3(10,200,0)

local SURVIVOR_IMGS = {"surv-man-1", "surv-woman-1"}

local FUZE_COLOR_IMGS = {
	[MainState.FUZE.RED] = "fuze_red",
	[MainState.FUZE.GREEN] = "fuze_green",
	[MainState.FUZE.BLUE] = "fuze_blue",
	[MainState.FUZE.YELLOW] = "fuze_yellow",
}

local function get_rotation(self, touch)
	--local to = go.get_position() - go.get_position("camera")
	local to = go.get_position() - self.camera_pos
	local from = vmath.vector3(touch.x, touch.y, 0)
	local angle = math.atan2(to.x - from.x, from.y - to.y)
	return vmath.quat_rotation_z(angle)
end

local function fire(self)
	local rotation = go.get_rotation()
	local position = go.get_position() + vmath.rotate(rotation, vmath.vector3(10, 30, 0))
	msg.post("/spawner-bullet#script", "add_bullet", {pos = position, rot = rotation, uid = self.uid})
	self.fire_cooldown = FIRE_COOLDOWN
end

local function trigger(self, action)
	if action.pressed then
		self.pressed_time = socket.gettime()
	elseif action.released then
		-- fire a bullet if the time between press and release is sufficiently short
		if socket.gettime() - self.pressed_time < 0.2 and self.fire_cooldown < 0 then
			fire(self)
		end
	end
end

local function update_fuzes(self)
	-- TODO sometimes players sprites are not visible
	msg.post("#sprite", "enable")
	msg.post("#name", "enable")
	msg.post("#scale", "enable")
	msg.post("#scale-fill", "enable")
	msg.post("#scale-health", "enable")
	msg.post("#scale-level", "enable")
	msg.post("#scale-manna", "enable")

	for i=1,#FUZE_COLOR_IMGS do msg.post(string.format("#sprite-fuze-%d", i), "disable") end

	local i = 1
	local sprite_url
	MainState.fuzeColorToPlayerUid:for_each(function(key_fuze_color, p_uid)
		if p_uid == self.uid then
			-- log("update_fuzes", key_fuze_color, p_uid)
			sprite_url = string.format("#sprite-fuze-%d", i)
			msg.post(sprite_url, "enable")
			sprite.play_flipbook(sprite_url, FUZE_COLOR_IMGS[key_fuze_color])
			i = i + 1
		end
	end)
end

local function throw_fuzes(self)
	for i=1,#FUZE_COLOR_IMGS do msg.post(string.format("#sprite-fuze-%d", i), "disable") end


	local to = go.get_position()
	MainState.fuzeColorToPlayerUid:for_each(function(fuze_color, p_uid)
		if p_uid == self.uid then
			MainState.fuzeColorToMapLevel[fuze_color] = MainState.players:get(self.uid).map_level
			MainState.fuzeColorToPlayerUid:remove(fuze_color)

			to.x = to.x + 30
			to.y = to.y + 30

			for fuze, color in pairs(MainState.fuzesIdToColor) do
				if fuze_color == color then
					go.set_position(to, fuze)
				end
			end

			-- msg.post("/factory#fuze", MSG.FUZE_FACTORY.throw_fuze.name, {map_level = MainState.players:get(self.uid).map_level, color = key_fuze_color, pos = pos})
			msg.post("/gui#player", "update_fuzes", {fuze_color = fuze_color})
		end
	end)
end

local function decrease_health(self, killer_uid)
	local player = MainState.players:get(self.uid)
	player.health = player.health - 20

	self.current_health_width = self.health_width * (player.health / 100)
	go.set("#scale-health", "size.x", self.current_health_width)

	if player.health <= 0 then
		if killer_uid ~= nil then
			local killer = MainState.players:get(killer_uid)
			killer.score = killer.score + 1
			msg.post(killer.go_id, "update_score", {uid = killer.uid, score = killer.score})
		end
		msg.post("/spawner-player#script", "remove_player", {
			uid = self.uid,
			player_id = go.get_id()})
	end
end

local function hit(self, killer_uid)
	if self.hit_cooldown > 0 then
		return
	end

	decrease_health(self, killer_uid)

	self.hit_cooldown = HIT_COOLDOWN
end

local function hit_by_zombie(self, killer_uid)
	if self.zombie_hit_cooldown > 0 then
		return
	end

	decrease_health(self, killer_uid)

	self.zombie_hit_cooldown = ZOMBIE_HIT_COOLDOWN
end

local function input_controls(self)
	if self.isServer then
		self.touch = multiplayer_input:touched(self.uid)

		if multiplayer_input:is_pressed(self.uid, ACTION_IDS.LEFT) then
			self.velocity.x = -self.player_speed
		elseif multiplayer_input:is_pressed(self.uid, ACTION_IDS.RIGHT) then
			self.velocity.x = self.player_speed
		else
			self.velocity.x = 0
		end

		if multiplayer_input:is_pressed(self.uid, ACTION_IDS.UP) then
			self.velocity.y = self.player_speed
		elseif multiplayer_input:is_pressed(self.uid, ACTION_IDS.DOWN) then
			self.velocity.y = -self.player_speed
		else
			self.velocity.y = 0
		end

		if multiplayer_input:is_pressed(self.uid, ACTION_IDS.USE) then
			log("use")
			self.btn_use_pressed = true
			
			if self.btn_use_pressed_delay_handle ~= nil then
				timer.cancel(self.btn_use_pressed_delay_handle)
			end

			self.btn_use_pressed_delay_handle = timer.delay(0.2, false, function()
				if self.btn_use_pressed then
					self.btn_use_pressed = false
					throw_fuzes(self)
				end
			end)
		end

		if multiplayer_input:is_pressed(self.uid, ACTION_IDS.TRIGGER) and not self.btn_trigger_pressed then
			self.btn_trigger_pressed = true
			timer.delay(0.2, false, function()
				if self.fire_cooldown < 0 then
					fire(self)
				end
				self.btn_trigger_pressed = false
			end)
		end

		local analog = multiplayer_input:analog_used(self.uid)
		if analog ~= nil then
			go.set_rotation(vmath.quat_rotation_z(math.atan2(analog.y, analog.x) + rad_minus90))
		end

		--log("input_controls", self.velocity.x, self.velocity.y)
	else
		self.is_action_active = true
		if input.is_pressed(ACTION_IDS.LEFT) then
			self.velocity.x = -self.player_speed
		elseif input.is_pressed(ACTION_IDS.RIGHT) then
			self.velocity.x = self.player_speed
		else
			self.velocity.x = 0
			self.is_action_active = false
		end

		if input.is_pressed(ACTION_IDS.UP) then
			self.velocity.y = self.player_speed
		elseif input.is_pressed(ACTION_IDS.DOWN) then
			self.velocity.y = -self.player_speed
		else
			self.velocity.y = 0
			self.is_action_active = false
		end
	end
end

local prev_pressed = {
	[ACTION_IDS.LEFT] = false,
	[ACTION_IDS.RIGHT] = false,
	[ACTION_IDS.UP] = false,
	[ACTION_IDS.DOWN] = false,
}

local function send_command(self, action_id, action)
	log("send_command", action_id, action.pressed, action.released)
	--action.pressed, action.released
	local need_send = true

	if prev_pressed[action_id] ~= nil then
		if action.released then
			need_send = true
			prev_pressed[action_id] = false
		elseif action.pressed then
			need_send = action.pressed and not prev_pressed[action_id]
			prev_pressed[action_id] = true
		end
	end

	if need_send then
		MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = action_id, action = action})
	end
end

local MAP_LEVEL_TO_MSG_GROUP = {
	[MainState.MAP_LEVELS.HOUSE] = MSG_GROUPS.WALL,
	[MainState.MAP_LEVELS.BASEMENT] = MSG_GROUPS.WALL_BASEMENT,
}

-- https://forum.defold.com/t/dynamic-physics-gos-occasionally-passing-through-static-gos/74617
local function check_hit_wall(self, from)
	local player = MainState.players:get(self.uid)
	if player == nil then
		return false
	end

	local collision_object_hash = MAP_LEVEL_TO_MSG_GROUP[player.map_level]
	local offset = 20
	local multiply = 1
	local to = from + vmath.vector3(offset, 0, 0)
	local hit_left = physics.raycast(from, to, { collision_object_hash })
	-- msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
	if hit_left then
		-- go.set_position(from - vmath.vector3(offset * multiply, 0, 0))
		return true
	end

	to = from + vmath.vector3(-offset, 0, 0)
	local hit_right = physics.raycast(from, to, { collision_object_hash })
	-- msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
	if hit_right then
		-- go.set_position(from - vmath.vector3(-offset * multiply, 0, 0))
		return true
	end

	to = from + vmath.vector3(0, offset * multiply, 0)
	local hit_up = physics.raycast(from, to, { collision_object_hash })
	-- msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
	if hit_up then
		-- go.set_position(from - vmath.vector3(0, offset * multiply, 0))
		return true
	end

	to = from + vmath.vector3(0, -offset, 0)
	local hit_down = physics.raycast(from, to, { collision_object_hash })
	-- msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = vmath.vector4(1,0,0,1) })
	if hit_down then
		-- go.set_position(from - vmath.vector3(0, -offset, 0))
		return true
	end

	return false
end

local function update_camera_position(self, pos, rotation)
	self.camera_pos = pos + vmath.vector3(-568, - 320, 0)

	if not self.isServer then
		-- update camera position
		go.set_position(self.camera_pos, "camera")
		go.set_position(pos + vmath.rotate(rotation, CROSSHAIR_OFFSET), "crosshair")
	end
end

local function update_cooldown(self, dt)
	self.stairs_change_cooldown = self.stairs_change_cooldown - dt
	self.fire_cooldown = self.fire_cooldown - dt

	if self.hit_cooldown < 0 then
		self.bullet_id = nil
	end
	self.hit_cooldown = self.hit_cooldown - dt
	self.zombie_hit_cooldown = self.zombie_hit_cooldown - dt
end

function init(self)
	log("player init", msg.url())
	local go_id = go.get_id()

	self.isServer = MainState.isServer
	self.stairs_change_cooldown = -1
	self.move = 0		-- direction of movement (0 = standing still, 1 = forward, -1 = backward)
	self.rotate = 0		-- direction of rotation (0 = no rotation, 1 = left, -1 = right)
	self.username = "user-" .. tostring(self.uid)
	self.velocity = vmath.vector3()
	self.sound_run_playing = false
	self.right_stick_value = vmath.vector3()
	self.virtualGamepadLeftStickTouchNum = 0
	self.health_width = go.get("#scale-health", "size.x")
	self.current_health_width = self.health_width
	self.hit_cooldown = HIT_COOLDOWN
	self.zombie_hit_cooldown = ZOMBIE_HIT_COOLDOWN
	self.fire_cooldown = 0
	self.btn_use_pressed = false
	self.camera_pos = vmath.vector3()
	self.is_hit_wall = false
	self.is_action_active = true
	self.player_speed = PLAYER_SPEED

	label.set_text("#name", MainState.player.username)

	-- print(self.map_level, self.player_type, MainState.PLAYER_TYPE.SURVIVOR)
	if self.player_type == MainState.PLAYER_TYPE.SURVIVOR then
		-- math.randomseed(os.time())
        -- self.index = math.random(1, 2)
        self.index = 1
		sprite.play_flipbook("#sprite", SURVIVOR_IMGS[self.index])
		-- go.set_rotation(vmath.quat_rotation_z(math.rad(-90)))
	end

	for i=1,#FUZE_COLOR_IMGS do msg.post(string.format("#sprite-fuze-%d", i), "disable") end

	local player = MainState.players:get(self.uid)
	local score = player and player.score or 0

	if player == nil then
		local prev_deleted_player = MainState.game_over_players:get(self.uid)
		score = prev_deleted_player and prev_deleted_player.score or 0
	end

	local obj = MainState.createGameObject(self.uid, self.username, go_id, self.player_type, self.map_level, score)

	MainState.players:put(obj.uid, obj)

	label.set_text("#scale-level", string.format("%d", score + 1))

	msg.post("/gui#menu", "set_online_players", {online_players = MainState.players.length})
	log("player joined: " .. self.username .. " remote: " .. tostring(self.remote))

	if self.isServer then
		MainState.register_gameobject(self.uid, go_id, MainState.FACTORY_TYPES.player)
	else
		msg.post("/broadsock", "register_gameobject", { id = go_id, type = MainState.FACTORY_TYPES.player })
	end

	if not self.remote and not self.isServer then
		log("remote = " .. tostring(self.remote))
		msg.post(".", "acquire_input_focus")
		msg.post("/camera", "acquire_camera_focus")
		input.acquire()

		msg.post("/levels#change", "load_level", {map_level = obj.map_level})

		if IS_MOBILE then
			msg.post("/virtual_gamepad", "enable")
			msg.post("/virtual_gamepad", "register")
		else
			msg.post("/virtual_gamepad", "disable")
		end
	end

	self.t = 0
	self.virtual_gamepad_left_pressed = false
	self.virtual_gamepad_right_pressed = false
	self.virtual_gamepad_up_pressed = false
	self.virtual_gamepad_down_pressed = false
	self.virtual_gamepad_player_rotation = true
end

function final(self)
	local go_id = go.get_id()

	if self.isServer then
		MainState.unregister_gameobject({ id = go_id })
	else
		msg.post("/broadsock", "unregister_gameobject", { id = go_id, killer_uid = self.killer_uid })
	end

	if not self.remote and not self.isServer then
		MainState.SOUND.loop_run.stop()
		self.sound_run_playing = false
		msg.post(".", "release_input_focus")
		msg.post("/camera", "release_camera_focus")
		input.release()
		msg.post("/virtual_gamepad", "unregister")
	end

	throw_fuzes(self)

	--if MainState.GAME_STATES.RUNNING ~= MainState.currentGameState then
	--	MainState.players:remove(self.uid)
	--	msg.post("/gui#menu", "set_online_players", {online_players = MainState.players.length})
	--	print("clear player", self.uid)
	--end

	--msg.post("/gui#menu", "create_player")
end

function update(self, dt)
	self.t = self.t + dt
	if MainState.pause then
		-- input_release_controls()
		return
	end

	if not self.isServer then
		update_fuzes(self)
		msg.post("@render:", "draw_text", { text = sys.get_config("html5.archive_location_suffix") .. " Arrows or WASD to move/turn. Mouse to turn. Left mouse button/Space to fire.", position = vmath.vector3(20, 20, 0) } )
	end

	local pos = go.get_position()
	pos = pos + self.velocity * dt

	if not self.remote then
		self.is_hit_wall = check_hit_wall(self, pos)
		if self.is_hit_wall then
			self.player_speed = PLAYER_SPEED_CLOSE_TO_WALL
		else
			self.player_speed = PLAYER_SPEED
		end
	end

	if not self.isServer and (self.remote or not self.is_action_active or self.touch == nil) then
		-- Find the two authoritative positions surrounding the rendering timestamp.
		local buffer = MainState.server_state_buffer:get(self.uid)
		if buffer == nil then
			return
		end

		local render_timestamp = get_timestamp_in_ms() - (1000 / MainState.server_update_rate);
		-- Drop older positions.
		while buffer.length >= 2 and buffer:get(2).ts <= render_timestamp do
			buffer:removeFirst()
			self.t = 0
		end
		-- Interpolate between the two surrounding authoritative positions.
		if buffer.length >= 2 and buffer:get(1).ts <= render_timestamp and render_timestamp <= buffer:get(2).ts and self.t <= 1 then
			local pos = vmath.lerp(self.t, buffer:get(1).pos, buffer:get(2).pos)
			go.set_position(pos)
			local rotation = vmath.slerp(self.t, buffer:get(1).rot, buffer:get(2).rot)
			go.set_rotation(rotation)
			local scale = vmath.slerp(self.t, buffer:get(1).scale, buffer:get(2).scale)
			go.set_scale(scale)

			if not self.remote then
				update_camera_position(self, pos, rotation)
				update_cooldown(self, dt)
			end
		end

		return
	end
	--if not self.isServer then
	--	return
	--end

	local rotation = go.get_rotation()
	if not MainState.HAS_GAMEPAD then
		-- handle rotation from key input left/right
		if self.rotate ~= 0 then
			rotation = rotation * vmath.quat_rotation_z(self.angular_velocity * self.rotate * dt)
			go.set_rotation(rotation)
		-- rotate towards the latest mouse/touch location
		-- take into account camera position
		elseif self.touch then
			rotation = get_rotation(self, self.touch)
			go.set_rotation(rotation)
			self.touch = nil
		end
	end

	-- move in direction of rotation
	go.set_position(pos)
	update_camera_position(self, pos, rotation)

	input_controls(self)
	update_cooldown(self, dt)
end

function on_input(self, action_id, action)
	if self.remote or self.isServer then
		return
	end
	-- print(action_id, action.value, action.pressed, action.released, "left stick", self.virtualGamepadLeftStickTouchNum)

	if action_id == ACTION_IDS.GAMEPAD.CONNECTED then
        if action.gamepad == 0 then
          -- gamepad 0 was connected
			log("gamepad_connected")
			MainState.HAS_GAMEPAD = true
			msg.post("/virtual_gamepad", "disable")
        end
    elseif action_id == ACTION_IDS.GAMEPAD.DISCONNECTED then
        if action.gamepad == 0 then
          -- gamepad 0 was dicconnected
		    log("gamepad_dicconnected")
			MainState.HAS_GAMEPAD = false
			if IS_MOBILE then
				msg.post("/virtual_gamepad", "enable")
			end
        end
    end

	if MainState.pause or insidePauseBound(action) then
		if self.sound_run_playing then
			MainState.SOUND.loop_run.stop()
			self.sound_run_playing = false
		end
        return
    end

	if MainState.HAS_GAMEPAD then
		-- FIX: Move with gamepad left stick
		if isGamepadLeftStickActionId[action_id] then
			if action_id == ACTION_IDS.GAMEPAD.LEFT_STICK.LEFT then
				self.velocity.x = -self.player_speed
			elseif action_id == ACTION_IDS.GAMEPAD.LEFT_STICK.RIGHT then
				self.velocity.x = self.player_speed
			end
			if action_id == ACTION_IDS.GAMEPAD.LEFT_STICK.UP then
				self.velocity.y = self.player_speed
			elseif action_id == ACTION_IDS.GAMEPAD.LEFT_STICK.DOWN then
				self.velocity.y = -self.player_speed
			end
		elseif isGamepadRightStickActionId[action_id] then
			if action_id == ACTION_IDS.GAMEPAD.RIGHT_STICK.LEFT then
				self.right_stick_value.x = -STICK_MAX_DISTANCE * action.value
			elseif action_id == ACTION_IDS.GAMEPAD.RIGHT_STICK.RIGHT then
				self.right_stick_value.x = STICK_MAX_DISTANCE * action.value
			elseif action_id == ACTION_IDS.GAMEPAD.RIGHT_STICK.UP then
				self.right_stick_value.y = STICK_MAX_DISTANCE * action.value
			elseif action_id == ACTION_IDS.GAMEPAD.RIGHT_STICK.DOWN then
				self.right_stick_value.y = -STICK_MAX_DISTANCE * action.value
			end

			if action.value ~= 0 then
				go.set_rotation(getRotation(go.get_position() + self.right_stick_value))
				-- go.set_rotation(vmath.quat_rotation_z(math.atan2(new_pos.y, new_pos.x)))
			end
		else
			input.update(action_id, action)
		end
	else
		input.update(action_id, action)
	end

	if action_id == ACTION_IDS.LEFT or action_id == ACTION_IDS.RIGHT or action_id == ACTION_IDS.UP or action_id == ACTION_IDS.DOWN then
		--print(action_id, action.value, action.pressed, action.released, action.x, action.y) -- a value between 0.0 an -1.0
		send_command(self, action_id, action)
		if action.pressed and not self.sound_run_playing then
			MainState.SOUND.loop_run.play()
			self.sound_run_playing = true
		elseif action.released and self.sound_run_playing then
			MainState.SOUND.loop_run.stop()
			self.sound_run_playing = false
		end
	end

	if action_id == ACTION_IDS.USE then
		-- print(action_id, action.value, action.pressed, action.released, action.x, action.y) -- a value between 0.0 an -1.0
		MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = action_id, action = action})
		-- if action.pressed then
		-- 	self.btn_use_pressed = true
		-- elseif action.released then
		-- 	self.btn_use_pressed = false
		-- 	throw_fuzes(self)
		-- end
	end

	if IS_MOBILE then
		-- if insideVirtualGamepadLeftStickBound(action) or defoldUtils.virtualGamepadLeftStickPressed then
		-- 	return
		-- end

		if action_id == hash("touch_multi") then
			-- Spawn at each touch point
			for i, touchdata in ipairs(action.touch) do
				-- print(i, "touchdata", touchdata.x, touchdata.y, touchdata.pressed, touchdata.released)
				if self.virtualGamepadLeftStickTouchNum == 0 and touchdata.pressed then
					if insideVirtualGamepadLeftStickBound(action) then
						self.virtualGamepadLeftStickTouchNum = i
					end
				end
				if self.virtualGamepadLeftStickTouchNum ~= i and not insideVirtualGamepadButtonsBounds(action) then
					MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = ACTION_IDS.TRIGGER, action = touchdata})
					--trigger(self, touchdata)
					if touchdata.pressed then
						go.set_rotation(get_rotation(self, touchdata))
						-- go.set_rotation(getRotation(go.get_position() + vmath.vector3(touchdata.x, touchdata.y, 0)))
						-- go.set_rotation(vmath.quat_rotation_z(math.atan2(touchdata.y, touchdata.x)))
					end
				end
				if self.virtualGamepadLeftStickTouchNum == i and touchdata.released then
					self.virtualGamepadLeftStickTouchNum = 0
				end
			end
		end

		if action_id == ACTION_IDS.TRIGGER then
			MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = action_id, action = action})
			--trigger(self, action)
		end

		if not action_id then
			if not insideVirtualGamepadButtonsBounds(action) and not insideVirtualGamepadLeftStickBound(action) and self.virtualGamepadLeftStickTouchNum == 0 then
				self.touch = action
				send_command(self, ACTION_IDS.TOUCH, action)
			end
		end
	else
		-- handle touch/mouse movement by holding down the finger/mouse button
		if (action_id == ACTION_IDS.TRIGGER or action_id == ACTION_IDS.TOUCH) then
			-- print(go.get_position())
			MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = action_id, action = action})
			--trigger(self, action)
		end

		if not action_id then
			self.touch = action
			send_command(self, ACTION_IDS.TOUCH, action)
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("update_health") then
		if self.uid == message.uid then
			self.current_health_width = self.health_width * (message.health / 100)
			go.set("#scale-health", "size.x", self.current_health_width)
		end
	elseif message_id == hash("update_score") then
		if self.uid == message.uid then
			label.set_text("#scale-level", string.format("%d", message.score + 1))

			particlefx.play("#level_up")
			MainState.SOUND.level_up()
			timer.delay(2, true, function ()
				particlefx.stop("#level_up")
			end)
			-- go.set("#scale-health", "size.x", self.health_width * (message.health / 100))
		end
	end

	--log(message_id, message.group, message.other_id, self.uid)
	if message_id == MSG_GROUPS.COLLISION_RESPONSE and self.isServer then
		if message.group == MSG_GROUPS.BULLET then
			local player_on_level = MainState.players:get(self.uid).map_level
			local bullet_uid = MainState.bulletIdToUid[message.other_id]
			--print("I collided with", self.uid, "bullet_uid = ", bullet_uid)

			if self.bullet_id ~= message.other_id and player_on_level == MainState.bulletUidBelongToMapLevel[bullet_uid] then
				self.bullet_id = message.other_id
				self.killer_uid = MainState.bulletBelongToPlayerUid[message.other_id]

				local killer = MainState.players:get(self.killer_uid)

				--print("I collided with", self.uid, "killer = ", killer.uid, "bullet_uid = ", bullet_uid)

				if killer == nil or killer.map_level ~= player_on_level then
					 return
				end

				hit(self, self.killer_uid)
			end
		elseif message.group == MSG_GROUPS.ZOMBIE then
			local player = MainState.players:get(self.uid)
			if player == nil then return end

			local player_on_level = player.map_level
			local zombie_uid = MainState.zombieIdToUid[message.other_id]
			local zombie = MainState.zombies:get(zombie_uid)

			if zombie ~= nil and zombie.map_level == player_on_level then
				hit_by_zombie(self, nil)
			end
		elseif message.group == MSG_GROUPS.FUZE then
			local player_on_level = MainState.players:get(self.uid).map_level
			local fuze_color = MainState.fuzesIdToColor[message.other_id]
			local player_uid = MainState.fuzeColorToPlayerUid:get(fuze_color)
			log("contact_fuze", message.group, message.other_id, fuze_color, self.uid, go.get_position(), go.get_position(message.other_id))

			if player_uid == nil and MainState.fuzeColorToMapLevel[fuze_color] == player_on_level and MainState.fuzeBoxColorToState[fuze_color] == 0 then
				--update_fuzes(self)
				-- msg.post("/factory#fuze", MSG.FUZE_FACTORY.pick_fuze.name, {color = fuze_color, player_uid = self.uid})
				MainState.fuzeColorToPlayerUid:put(fuze_color, self.uid)
				msg.post("/gui#player", "update_fuzes", {fuze_color = fuze_color})
			end
		elseif message.group == MSG_GROUPS.FUZE_BOX then
			local player_on_level = MainState.players:get(self.uid).map_level
			local fuze_box_color = MainState.fuzeBoxIdsToColor[message.other_id]
			log("contact_fuze_box", message.group, self.btn_use_pressed)

			if self.btn_use_pressed and self.isServer and MainState.fuzeBoxColorToMapLevel[fuze_box_color] == player_on_level then
				log("fuze_box_hit", fuze_box_color, message_id, message.group)
				
				self.btn_use_pressed = false

				if MainState.fuzeColorToPlayerUid:has(fuze_box_color) then
					msg.post(message.other_id, "fuze_box_fixed", {fuze_box_color = fuze_box_color})
					MainState.fuzeColorToPlayerUid:remove(fuze_box_color)
					update_fuzes(self)
				else
					local pos = go.get_position()
					pos.x = pos.x + 50
					go.set_position(pos)
					hit_by_zombie(self, nil)
				end
			end
		elseif message.group == MSG_GROUPS.EXIT then
			broadsock.sendGameOver(MainState.PLAYER_TYPE.SURVIVOR)
			--msg.post("/gui#menu", "player_exit", {})
		end
	elseif message_id == MSG_GROUPS.CONTACT_POINT_RESPONSE then
		local player = MainState.players:get(self.uid)
		if player == nil then return end

		local player_on_level = player.map_level
		local player_hit_wall_house = player_on_level == MainState.MAP_LEVELS.HOUSE and message.group == MSG_GROUPS.WALL
		local player_hit_wall_basement = player_on_level == MainState.MAP_LEVELS.BASEMENT and message.group == MSG_GROUPS.WALL_BASEMENT

		if player_hit_wall_house or player_hit_wall_basement then
			log("contact_point_response", message.group, message.normal, message.distance, self.is_hit_wall, self.player_speed, "x=", self.velocity.x, "y=", self.velocity.y)
			-- https://forum.defold.com/t/there-is-a-bug-with-collisions-in-my-game/77002/14
			-- Some things I’d try to do:
			-- 0. Enable Physics Debugging in game.project!
			-- 1. Put a limit to the velocity. Do not apply more force if your linear velocity is above a certain treshold
			-- 2. Perhaps do some prediction using ray casts to know if you are about to collide (and do “something”)
			-- 3. And apply an opposite force on collision to fight tunneling
			go.set_position(go.get_position() + message.normal * message.distance)
		end

		if self.stairs_change_cooldown < 0 then
			if message.group == STAIRS_TO_BASEMENT then
				if not self.isServer then
					msg.post("/levels#change", "load_level", {map_level = MainState.MAP_LEVELS.BASEMENT})
				end
				MainState.players:get(self.uid).map_level = MainState.MAP_LEVELS.BASEMENT
				self.stairs_change_cooldown = STAIRS_CHANGE_COOLDOWN
			elseif message.group == STAIRS_TO_HOUSE then
				if not self.isServer then
					msg.post("/levels#change", "load_level", {map_level = MainState.MAP_LEVELS.HOUSE})
				end
				MainState.players:get(self.uid).map_level = MainState.MAP_LEVELS.HOUSE
				self.stairs_change_cooldown = STAIRS_CHANGE_COOLDOWN
			end
		end
	end

	if self.remote or self.isServer then
		return
	end

	if message_id == ACTION_IDS.VIRTUAL_GAMEPAD.ANALOG then
		--  print("analog: x", message.x, " - y", message.y, message.pressed, message.released)
		-- self.speed.x = message.x * 200
		-- self.speed.y = message.y * 200
		local action = {pressed = false, released = false, x = message.x, y = message.y}

		if message.x < 0 then
			if self.virtual_gamepad_right_pressed then
				send_command(self, ACTION_IDS.RIGHT, {pressed = false, released = true, x = message.x, y = message.y})
				self.virtual_gamepad_right_pressed = false
			end
			self.virtual_gamepad_left_pressed = true
			action.pressed = true
			send_command(self, ACTION_IDS.LEFT, action)
			self.velocity.x = -self.player_speed
		elseif message.x > 0 then
			if self.virtual_gamepad_left_pressed then
				send_command(self, ACTION_IDS.LEFT, {pressed = false, released = true, x = message.x, y = message.y})
				self.virtual_gamepad_left_pressed = false
			end
			self.virtual_gamepad_right_pressed = true
			action.pressed = true
			send_command(self, ACTION_IDS.RIGHT, action)
			self.velocity.x = self.player_speed
		elseif self.virtual_gamepad_left_pressed or self.virtual_gamepad_right_pressed then
			action.released = true
			send_command(self, ACTION_IDS.LEFT, action)
			send_command(self, ACTION_IDS.RIGHT, action)
			self.velocity.x = 0
		end

		if message.y > 0 then
			if self.virtual_gamepad_down_pressed then
				send_command(self, ACTION_IDS.DOWN, {pressed = false, released = true, x = message.x, y = message.y})
				self.virtual_gamepad_down_pressed = false
			end
			self.virtual_gamepad_up_pressed = true
			action.pressed = true
			send_command(self, ACTION_IDS.UP, action)
			self.velocity.y = self.player_speed
		elseif message.y < 0 then
			if self.virtual_gamepad_up_pressed then
				send_command(self, ACTION_IDS.UP, {pressed = false, released = true, x = message.x, y = message.y})
				self.virtual_gamepad_up_pressed = false
			end
			self.virtual_gamepad_down_pressed = true
			action.pressed = true
			send_command(self, ACTION_IDS.DOWN, action)
			self.velocity.y = -self.player_speed
		elseif self.virtual_gamepad_up_pressed or self.virtual_gamepad_down_pressed then
			action.released = true
			send_command(self, ACTION_IDS.UP, action)
			send_command(self, ACTION_IDS.DOWN, action)
			self.velocity.y = 0
		end

		if self.virtual_gamepad_player_rotation then
			if message.x ~= 0 or message.y ~= 0 then
				MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = ACTION_IDS.VIRTUAL_GAMEPAD.ANALOG, action = action})
				--print(message.x, message.y, math.atan2(message.y, message.x), math.rad(-90))
				--go.set_rotation(get_rotation(message))
				go.set_rotation(vmath.quat_rotation_z(math.atan2(message.y, message.x) + rad_minus90))
			end
		end
	elseif message_id == ACTION_IDS.VIRTUAL_GAMEPAD.BUTTON_A then
		MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = ACTION_IDS.TRIGGER, action = message})
	elseif message_id == ACTION_IDS.VIRTUAL_GAMEPAD.BUTTON_B then
		MSG.BROADSOCK:send_command({player_uid = MainState.player.uid, action_id = ACTION_IDS.USE, action = message})
	end
end
